#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
void main() {
	char ch;
	int a, b, c;
	int temp = 0;
	float f1, f2;
	a = b = c = 100;
	temp = a++ + ++b;
	temp += a-- + c++;
	printf("a=%d, b=%d, c=%d, temp=%d\n", a, b, c, temp);
	printf("\na값은 9번째 줄에서 1 추가되었다가 10번째 줄에서 1 빠지기 때문에 결국 원래대로 100이 나온다.\nb는 9번째 줄에서 1 추가되기 때문에 101이 된다.\nc는 10번째 줄에서 1 추가되기 때문에 101이 된다.\n마지막으로 temp는 9번째 줄에서 a(100) + b(101)이 되어 201이 되었다가, 10번째 줄에서 a(101) + c(100)이 추가로 더해져서 총 402가 된다.\ntemp계산에 대해 더 자세히 말하자면 변수 뒤에 ++가 붙는지 앞에 ++가 붙는지에 따라 결과가 달라진다.\n예를 들어 9번 줄에서 a++는 9번줄 연산에선 a값이 사용되었다가, 다음 줄로 넘어가면 그제서야 a값에 1이 추가된다.\n이렇게 1이 언제 추가되냐에 따라 연산이 달라진다.\n\n\n");
	a = 10;
	printf("15<%d<20 == %d\n", a, 15 < a < 20);
	printf("\na값은 10으로 15와 20사이가 아니지만 15 < a && a < 20 으로 쓰지 않고 두 비교를 한 번에 썼기 때문에 15 < a 의 값인 0과 20을 비교하게 된다.\n\n\n");
	printf("!!%d == %d\n", a, !!a);
	printf("\na값은 10인데 그것에 느낌표 기호를 붙히면 true와 false가 바뀐다. 10은 양의 정수로 true로 취급되기 때문에 !10은 0이고, !!10은 0이 다시 1로 바뀌게 되어 결과가 1로 나온다.\n1은 true를 대표하는 값이기에 10이 아니라 1이 나온다.\n\n\n");
	ch = 'a';
	temp = 'A' <= ch && ch <= 'z';
	printf("temp = %d\n", temp);
	printf("\n대문자 알파벳들과 소문자 알파벳들은 아스키 코드 범위가 다르다. 소문자들이 더 뒤에 있기 때문에 A부터 z까지의 문자는 모든 알파벳을 포함할 뿐 아니라 그 사이의 값들도 포함한다.\nch값이 알파벳이므로 반드시 temp는 참이되어서 결과가 1로 나오는 것이다.\n\n\n");
	f1 = 5e+20;
	f2 = 0.1;
	printf("f1<f1+f2 == %d\n", f1 < f1 + f2);
	printf("\nfloat의 정확도는 제한적이다.\nf1의 값이 float의 범위를 초과하진 않지만 f1의 값이 너무 커서 0.1을 더하는 정도로는 변하지 않을 정도로 정확도가 낮아지게 된다. 그래서 결과가 정확히 나오지 않는다.\n\n\n");
}